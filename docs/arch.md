# Архитектурная документация

## Цель

Разработать расширяемый интерпретатор командной строки с поддержкой:

* встроенных команд;
* кавычек (quoting);
* переменных окружения;
* пайплайнов;
* внешних программ.

---

## Краткое описание архитектуры

### Основные модули

#### Lexer

* Разбивает входную строку на токены:

  * слова;
  * одиночные и двойные кавычки;
  * операторы (`|`, `=`, `$`);
  * специальные символы;
  * `EOF`.
* Учитывает правила quoting (full vs weak).
* Обрабатывает escape-последовательности.
* Результат работы: `TokenStream` (`std::vector<Token>`).

#### CommandParser

* Преобразует `TokenStream` в набор команд с аргументами.
* Запись в переменную окружения трактуется как отдельная команда.
* Возвращает `Pipe` (`std::vector<ParsedCommand>`).

#### PipeExecutor

* Последовательно обрабатывает команды пайплайна.
* Для каждой команды вызывает `CommandExecutor`.
* Перенаправляет потоки ввода, вывода и ошибок между командами.

#### ReaderT / WriterT

* Алиасы для:

  * `ReaderT` → `std::istream`;
  * `WriterT` → `std::ostream`.

#### CommandExecutor

* Предобрабатывает аргументы с помощью `expand`.
* Получает реализацию команды из `CommandManager`.
* Выполняет одну команду в отдельном потоке.
* Обрабатывает ошибки выполнения.

#### CommandManager

* Связывает строковое имя команды с `enum`-идентификатором.
* По `enum` возвращает указатель на реализацию команды (`run`).

#### ExecutionContext

* Хранит глобальное состояние интерпретатора:

  * переменные окружения;
  * текущую директорию;
  * флаги завершения (например, `IsExit`).

---

## Выполнение команд

### Интерфейс команд

```cpp 
void expand(std::vector<std::string>&, ExecutinContext&)
```

* Выполняет подстановку переменных окружения.

```cpp
template <enum Command>
void run(ReaderT input, WriterT output, WriterT error);
```

* Реализация встроенных команд.
* Или вызов внешней программы.

---

## Принцип работы

1. Считывается входная строка пользователя.
2. `Lexer` преобразует строку в набор токенов.
3. `CommandParser` преобразует токены в набор команд (`Pipe`).
4. `PipeExecutor` последовательно выполняет команды пайплайна через `CommandExecutor`.
5. `CommandExecutor`:

   * подготавливает аргументы с помощью `expand`;
   * если команда реализована (включая присваивание), вызывает соответствующий `run<>`;
   * если команда не найдена — вызывает внешнюю команду `process`, передавая имя и аргументы.
6. Ошибки перехватываются и их сообщения записываются в поток ошибок.
7. Если была вызвана команда `exit`, в `ExecutionContext` устанавливается флаг `IsExit`.
8. После завершения пайплайна интерпретатор корректно завершает работу.

## UML-диаграмма архитектуры

![UML диаграмма архитектуры интерпретатора](resources/uml-architecture.png)
